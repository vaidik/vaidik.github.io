<!doctype html>
<!-- https://github.com/paulirish/html5-boilerplate/blob/master/index.html -->
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
    <meta charset="">

  <!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
       Remove this if you use the .htaccess -->
  <meta http-equiv="X-UA-Compatible" content="">

  <!-- encoding must be specified within the first 512 bytes
        www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#charset -->

  <!-- meta element for compatibility mode needs to be before
        all elements except title & meta
        msdn.microsoft.com/en-us/library/cc288325(VS.85).aspx -->
  <!-- Chrome Frame is only invoked if meta element for
        compatibility mode is within the first 1K bytes
        code.google.com/p/chromium/issues/detail?id=23003 -->

  <title>Incoming - JSON Validation Framework for Python</title>
  <meta name="description" content="Incoming is a JSON validation framework for Python. Validation of payloads sent over HTTP requests has always been a mess. A bunch of if-then-else further branching into more if-then-else blocks is common and over time becomes extremely difficult to manage. Since REST APIs and the use of JSON for HTTP payload is commong practice, it only made sense to solve the problem of payload validation for JSON payloads. Incoming is an opinionated JSON validation framework which does not bind to any kind of web frameworks. It just tries to make JSON validation sensible and logical by giving it structure and making it possible to re-use validation code across your application.">
  <meta name="author" content="Vaidik Kapoor">

  <meta prefix="og: http://ogp.me/ns#" property="og:title" content="Incoming - JSON Validation Framework for Python" />
  <meta prefix="og: http://ogp.me/ns#" property="og:description" content="Incoming is a JSON validation framework for Python. Validation of payloads sent over HTTP requests has always been a mess. A bunch of if-then-else further branching into more if-then-else blocks is common and over time becomes extremely difficult to manage. Since REST APIs and the use of JSON for HTTP payload is commong practice, it only made sense to solve the problem of payload validation for JSON payloads. Incoming is an opinionated JSON validation framework which does not bind to any kind of web frameworks. It just tries to make JSON validation sensible and logical by giving it structure and making it possible to re-use validation code across your application." />

  <!--  Mobile viewport optimized: j.mp/bplateviewport -->
  <meta name="viewport" content="">

    <!-- Place favicon.ico & apple-touch-icon.png
        in the root of your domain and delete these references -->
  <link rel="shortcut icon" href="/media/favicon.ico">
  <link rel="apple-touch-icon" href="/media/apple-touch-icon.png">
  
  <!-- External Fonts -->
  <link href='http://fonts.googleapis.com/css?family=Mate+SC|Oxygen' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Balthazar' rel='stylesheet' type='text/css'>

  <!-- highlight.js -->
  <link rel="stylesheet" href="http://yandex.st/highlightjs/7.3/styles/default.min.css">
  <script src="http://yandex.st/highlightjs/7.3/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" href="/media/css/site.css">
  <link rel="stylesheet" href="/media/css/syntax.css">
  
    <!-- All JavaScript at the bottom, except for Modernizr which
        enables HTML5 elements & feature detects -->
    <script src="/media/js/libs/modernizr-1.7.min.js"></script>
    </head>
<body id="incoming-python-json-validation-framework">
    <div id="container">
            <div id="main" role="main">
          <header class="clearfix">
              <h1>Vaidik Kapoor</h1>
                                          <nav >
        <a title="Home Page"
        class="home"
        href="/index.html">
        Home
    </a>    <a title="Blog Archives"
        class="active blog"
        href="/blog">
        Archives
    </a>    <a title="About"
        class="about"
        href="/about.html">
        About
    </a></nav>
              
          </header>

          <section class="content">
              <div class="post">
        <article>
            <aside>
                <time datetime="2015-03-02">
                    March 02, 2015
                </time>
            </aside>
            <section>
                <h2>
                    <a href="">Incoming - JSON Validation Framework for Python</a>
                </h2>
                <p><a href="https://github.com/vaidik/incoming">Incoming</a> is a <span class="caps">JSON</span> validation framework for Python. Validation of payloads
sent over <span class="caps">HTTP</span> requests has always been a mess. A bunch of if-then-else
further branching into more if-then-else blocks is common and over time
becomes extremely difficult to manage. Since the use of <span class="caps">JSON</span>
for <span class="caps">HTTP</span> payload is a common practice, it only made sense to solve the
problem of payload validation for payloads in <span class="caps">JSON</span> format. <a href="https://github.com/vaidik/incoming">Incoming</a> is an opinionated
<span class="caps">JSON</span> validation framework which does not bind to any kind of web frameworks.
It just tries to make <span class="caps">JSON</span> validation sensible and logical by giving it
structure and making it possible to re-use validation code across your&nbsp;application.</p>
<h3>The&nbsp;Problem</h3>
<p>Payload validation is a common problem that makes your web applications messy
and difficult to maintain. Especially if you are doing <span class="caps">API</span> development, getting
tangled in a bunch of if-then-else blocks happens really quickly. But that&#8217;s not
the end of it. There are more problems that may come out or grow over time.
Let&#8217;s list them down&nbsp;here:</p>
<ol>
<li>Bunch of if-then-else blocks tangled with each other, which make management
   of code extremely&nbsp;difficult.</li>
<li>Abstracting out validation logic may become difficult over time, not because
   it is difficult, but there is no logical place to put all that&nbsp;together.</li>
<li>Reporting validation failures becomes too messy and difficult because there
   is no proper way to do it. You end up reporting validation failures&nbsp;incorrectly.</li>
</ol>
<p>Put all these issues together, it makes sense to solve these problems together
as they seem common to most of the web applications, especially those that are
heavy on&nbsp;APIs.</p>
<h3>The Solution - <a href="https://github.com/vaidik/incoming">Incoming</a></h3>
<p><a href="https://github.com/vaidik/incoming">Incoming</a> is an opinionated <span class="caps">JSON</span> validation framework that makes it
possible to validate <span class="caps">JSON</span> payloads with ease using structure. Its just a small
framework that makes it possible for you to solve the problems as listed in the
previous section in a sane&nbsp;way.</p>
<p>Although <a href="https://github.com/vaidik/incoming">Incoming</a> is a framework or task agnostic <span class="caps">JSON</span> validation
framework and it does not have to do anything with what it is used for, let&#8217;s
use <span class="caps">HTTP</span> APIs as a reference for the sake of this&nbsp;post.</p>
<h4>Structuring payload validation code into&nbsp;classes</h4>
<p>First thing&#8217;s first, let&#8217;s get a place in our application to put together all
our payload validation code. How and why would this work? Usually, every <span class="caps">HTTP</span>
<span class="caps">API</span> end-point accepts a kind of payload that has a set format. In case of <span class="caps">REST</span>
APIs, the resources have a format for the payload. So it is possible to put
together all the validation in some place for an end-point or an <span class="caps">API</span>.
<a href="https://github.com/vaidik/incoming">Incoming</a> makes it possible for you. Let&#8217;s get introduced to
Incoming&#8217;s&nbsp;<span class="caps">API</span>.</p>
<p>Consider that there is an <span class="caps">HTTP</span> <span class="caps">API</span> that expects the following <span class="caps">JSON</span>&nbsp;payload:</p>
<pre><code>{
    "name": "Vaidik" // string,
    "age": 16 // integer,
    "gender": "male" // string, male or female only
}
</code></pre>
<p>To validate the above payload using Incoming, we can write the validator like&nbsp;so:</p>
<pre><code>import json

from incoming import datatypes, PayloadValidator

class PersonValidator(PayloadValidator):

    name = datatypes.String()
    age = datatypes.Integer()
    gender = datatypes.Function('validate_gender')

    def validate_gender(self, val, **kwargs):
        val = val.lower()
        if val == 'male' or val == 'female':
            return True
        return False

validator = PersonValidator()

payload1 = {
    'name': 'Vaidik Kapoor',
    'age': 16.5,
    'gender': 'mail'
}
validator.validate(payload1)
'''
Returns:
(False,
 {'age': ['Invalid data. Expected an integer.'],
  'gender': ['Invalid data.']})
'''

payload2 = {
    'name': 'Vaidik Kapoor',
    'age': 16,
    'gender': 'male'
}
validator.validate(payload2)
'''
Returns:
(True, None)
'''
</code></pre>
<p>This is a simple payload validator written using Incoming. This shows how
Incoming makes it possible for you to quickly do simple validations of
fundamental data types and at the same time allows you to do validations using
separate methods. These methods don&#8217;t have to be instance methods. Instead they
can be static methods or class methods or even functions as&nbsp;well.</p>
<h4>Getting rid of tangled if-then-else blocks which are difficult to&nbsp;read</h4>
<p>Consider the following&nbsp;example:</p>
<pre><code>{
    "name": "Vaidik", // string
    "age": 16, // integer
    "gender": "male" // string, male or female only
    "department": "engineering", // string, possible values are engineering,
                                 // marketing, sales
    "github": "https://github.com/vaidik" // string, required if department
                                          // is engineering
}
</code></pre>
<p>There are two new fields in this example. One is <code>department</code> - this field can
take <code>engineering</code>, <code>marketing</code> and <code>sales</code> as values. There is another optional
field called <code>github</code>. This field is required only if <code>department</code> is
<code>engineering</code>.</p>
<p>This is how we can validate this using&nbsp;Incoming:</p>
<pre><code>import json

from incoming import datatypes, PayloadValidator

class PersonValidator(PayloadValidator):

    name = datatypes.String()
    age = datatypes.Integer()
    gender = datatypes.Function('validate_gender',
                                required=False)
    department = datatypes.Function('validate_department')
    github = datatypes.Function('validate_github', required=False)

    def validate_gender(self, val, **kwargs):
        if val == 'male' or val == 'female':
            return True
        return False

    def validate_department(self, val, **kwargs):
        if val in ('engineering', 'marketing', 'sales'):
            return True
        return False

    # the entire payload is passed to every validation method or
    # function
    def validate_github(self, val, payload, **kwargs):
        if payload.get('department', None) == 'engineering':
            if val is None:
                return False
        return True
</code></pre>
<p>We can see that you can now easily validate the field <code>github</code> and the
validation may depend on the value of other fields. How we do that is that we
pass the entire payload to every validation function or method as a keyword
argument. You can make use of this to write validation rules for one field that
may depend on the values of other field or&nbsp;fields.</p>
<h4>Organizing validation logic and code in a more sensible&nbsp;place</h4>
<p>Incoming tries to make validation more organized and structured as usually
validation is the part that goes every where in your application and starts
scattering really&nbsp;quickly.</p>
<p>I introduced Incoming for validation earlier in this article with an example,
wherein we used classes for organizing validation code for <span class="caps">JSON</span> payloads. So
here is the first thing - Incoming makes use of classes to make it possible to
put together validation for different types of&nbsp;payloads.</p>
<p>Other than validation of basic fundamental data types, Incoming provides ways to
use functions or methods to write validation logic for handling more complex
types of validations. And in real-world applications, you will end up having
complex validations. Important thing is that if you can organize this validation
logic and make it re-usable so that the same logic can be used outside of the
scope of Incoming if you choose to do so. In the previous examples, we have used
instance methods for validation. However, Incoming also supports you to use
static methods, class methods and functions as well for writing validations. So
instance methods work just fine but in case you want to use the same logic at
other places in your application, you can look at functions, class methods or
static methods as well. See the following&nbsp;example:</p>
<pre><code>import json

from incoming import datatypes, PayloadValidator

def validate_age(val, **kwargs):
    if val &gt; 0:
        return True
    return False

class PersonValidator(PayloadValidator):

    name = datatypes.String()
    age = datatypes.Function(validate_age)  # notice that reference to
                                            # validation function is
                                            # passed instead of name of the
                                            # method as a string in other
                                            # cases
    gender = datatypes.Function('validate_gender',
                                required=False)
    department = datatypes.Function('validate_department')
    github = datatypes.Function('validate_github', required=False)

    @classmethod
    def validate_gender(cls, val, **kwargs):
        if val == 'male' or val == 'female':
            return True
        return False

    def validate_department(self, val, **kwargs):
        if val in ('engineering', 'marketing', 'sales'):
            return True
        return False

    # the entire payload is passed to every validation method or
    # function
    @staticmethod
    def validate_github(val, payload, **kwargs):
        if payload.get('department', None) == 'engineering':
            if val is None:
                return False
        return True
</code></pre>
<p>Notice that <code>validate_age</code> is a function, <code>validate_gender</code> is a class method
and <code>validate_github</code> is a static method. This makes all the three callables
useful outside the scope of Incoming as&nbsp;well.</p>
<h4>Reporting validation failures with proper error&nbsp;messages</h4>
<p>This is the kicker. Getting error messages right becomes as difficult and makes
things even more messier and you can easily start loosing consistency in error
messages very soon. Incoming makes it possible for you to handle error messages&nbsp;nicely.</p>
<p>Incoming validates each and every field that is provided in the payload and that
is absent in the payload but was mentioned in the payload validator&#8217;s
definition. Every time validation fails for any field, Incoming catches the
failure and returns sensible error messages. Consider the following&nbsp;example:</p>
<pre><code>import json

from incoming import datatypes, PayloadValidator

class PersonValidator(PayloadValidator):

    name = datatypes.String()
    age = datatypes.Integer()
    gender = datatypes.Function('validate_gender',
                                required=False)
    department = datatypes.Function('validate_department')
    github = datatypes.Function('validate_github', required=False)

    def validate_gender(self, val, **kwargs):
        if val == 'male' or val == 'female':
            return True
        return False

    def validate_department(self, val, **kwargs):
        if val in ('engineering', 'marketing', 'sales'):
            return True
        return False

    # the entire payload is passed to every validation method or
    # function
    def validate_github(self, val, payload, **kwargs):
        if payload.get('department', None) == 'engineering':
            if val is None:
                return False
        return True

validator = PersonValidator()
validator.validate(dict(name='Vaidik', age=16.5, gender='mail'))
'''
Returns:
(False,
 {'age': ['Invalid data. Expected an integer.'],
  'department': ['Expecting a value for this field.'],
  'gender': ['Invalid data.']})
'''
</code></pre>
<p>Incoming does not stop validating other fields after first validation failure.
The reason behind this decision was that all the validation failures should be
reported at once so that the end user can fix the payload before trying again
and keep on doing hit-and-trial. And part of the reason behind this decision was
because Incoming was written for web applications to start with, which usually
have APIs with end users or consumers. Making multiple requests for every field
in the payload just for checking if the payload validates is rather painful for
the end&nbsp;user.</p>
<p>Note that the validation for both <code>age</code> and <code>gender</code> failed. Since <code>age</code> is of
type <code>Integer</code>, Incoming returned an error message saying that an integer was
expected. In case of &#8216;gender&#8217;, Incoming just says <code>Invalid data.</code> because in
case of type <code>Function</code>, Incoming does not know the reason of failure. While 
this is a good beginning for handling error messages, the error message in case
of <code>gender</code> field is not very helpful to the end&nbsp;user.</p>
<p>There is support for custom error messages when validation fails. This means
that although Incoing has sane error messages by default, you can always add
more accurate error messages with respect to your application. Furthermore,
Incoming allows you to control error messages for every field in your payload.
Consider the following&nbsp;example:</p>
<pre><code>import json

from incoming import datatypes, PayloadValidator

class PersonValidator(PayloadValidator):

    name = datatypes.String(error='name must be a string')
    age = datatypes.Integer(error='age must be an integer')
    gender = datatypes.Function('validate_gender',
                                required=False,
                                error=('gender can be either male or
                                       'female'))
    department = datatypes.Function('validate_department')
    github = datatypes.Function('validate_github', required=False)

    def validate_gender(self, val, **kwargs):
        if val == 'male' or val == 'female':
            return True
        return False

    def validate_department(self, val, **kwargs):
        if val in ('engineering', 'marketing', 'sales'):
            return True
        return False

    # the entire payload is passed to every validation method or
    # function
    def validate_github(self, val, payload, **kwargs):
        if payload.get('department', None) == 'engineering':
            if val is None:
                return False
        return True

validator = PersonValidator()
validator.validate(dict(name='Vaidik', age=16.5, gender='mail'))
'''
Returns:
(False,
 {'age': ['age must be an integer'],
  'department': ['Expecting a value for this field.'],
  'gender': ['gender can be either male or female']})
'''
</code></pre>
<p>Notice that you can easily override error messages while defining your validator
class. Every field type accepts a keyword argument called <code>error</code> which takes a
string as a value which shall be used if the field&#8217;s value in the payload is&nbsp;invalid.</p>
<p>With fields that have complicated validation logic, one generic error message
may not be enough. You can conditionally push additional error messages in your
validation functions or methods. Every validation function or method gets a
keyword argument called <code>errors</code> which is an array of error messages for that
field. You can push error messages in the array easily, like&nbsp;so:</p>
<pre><code>import json

from incoming import datatypes, PayloadValidator

class PersonValidator(PayloadValidator):

    name = datatypes.String(error='name must be a string')
    age = datatypes.Integer(error='age must be an integer')
    gender = datatypes.Function('validate_gender',
                                required=False,
                                error=('gender can be either male or '
                                       'female'))
    department = datatypes.Function('validate_department')
    github = datatypes.Function('validate_github', required=False)

    def validate_gender(self, val, **kwargs):
        if val == 'male' or val == 'female':
            return True
        return False

    def validate_department(self, val, **kwargs):
        if val in ('engineering', 'marketing', 'sales'):
            return True
        return False

    def validate_github(self, val, payload, errors, **kwargs):
        if payload.get('department', None) == 'engineering':
            if val is None:
                errors.append('Value required for github when department '
                              'is set to "engineering".')
                return False
            elif 'github.com' not in val:
                errors.append('Value for field github must be a valid '
                              'Github profile link.')
                return False
        return True

validator = PersonValidator()
validator.validate(dict(name='Vaidik', age=16, department='engineering'))
'''
Returns:
(False,
 {'gender': ['gender can be either male or female'],
  'github': ['Invalid data.',
             'Value required for github when department is set to "engineering".']})
'''

validator.validate(dict(name='Vaidik', age=16, department='engineering',
                    github='http://gitub.com/vaidik'))
'''
Returns:
(False,
 {'gender': ['gender can be either male or female'],
  'github': ['Invalid data.',
             'Value for field github must be a valid Github profile link.']})
'''

validator.validate(dict(name='Vaidik', age=16, department='engineering',
                        github='http://github.com/vaidik'))
'''
Returns:
(False, {'gender': ['gender can be either male or female']})
'''
</code></pre>
<p>Incoming also has the notion of <code>required</code> fields. By default, all fields are
required. If a required field is missing, Incoming reports that in the
validation response. For the above validator class, lets try to validate the
following&nbsp;payload:</p>
<pre><code>validator.validate(dict(name='Vaidik', age=10))
'''
Returns:
(False, {'department': ['Expecting a value for this field.']})
'''
</code></pre>
<p>By default, Incoming will use the above error message for missing required
fields in the payload. This message can be overridden in the class definition
by setting a class variable <code>required_error</code> like&nbsp;so:</p>
<pre><code>class PersonValidator(PayloadValidator):

    required_error = 'A value for this field must be provided.'
    ...

validator.validate(dict(name='Vaidik', age=10))
'''
Returns:
(False, {'department': ['A value for this field must be provided.']})
'''
</code></pre>
<p>The above example shows how you can customize your error messages for missing
fields that are&nbsp;required.</p>
<h3>Wrap&nbsp;Up</h3>
<p>There are many things that I was not able to cover in this blog post. You can
find them in the <a href="http://incoming.readthedocs.org/en/latest/">docs</a>.</p>
<p>My personal pains with validating payloads led me to work on Incoming. It seems
like a decent solution to me as of now. I tried my best to cover as many
use-cases as possible but I will not be surprised if I have missed some. I have
tried my best to keep the <span class="caps">API</span> as simple, tidy and easy to comprehend as
possible with a lot of focus on readability of validators. And I sure will be
adding features to Incoming in the near future as the need&nbsp;arises.</p>
<p>Does this look like a decent solutin to you? Would you use it in your next
application? Yes or no - I would love to hear your&nbsp;thoughts!</p>            </section>
        </article>

        <section>
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                var disqus_shortname = 'vaidikkapoor'; // required: replace example with your forum shortname

                /* * * DON'T EDIT BELOW THIS LINE * * */
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </section>
    </div>          </section>
      </div>

      <footer>
                              <nav >
        <a title="Home Page"
        class="home"
        href="/index.html">
        Home
    </a>    <a title="Blog Archives"
        class="active blog"
        href="/blog">
        Archives
    </a>    <a title="About"
        class="about"
        href="/about.html">
        About
    </a></nav>
                    <section class="credits">
              Built using <a href="http://ringce.com/hyde" target="_blank">Hyde</a>.
          </section>
      </footer>
      </div> <!--! end of #container -->
  
    <!-- Javascript at the bottom for fast page loading -->
    <!-- Grab Google CDN's jQuery, with a protocol relative URL; fall back to local if necessary -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.js"></script>
  <script>window.jQuery || document.write('<script src="js/libs/jquery-1.5.1.min.js">\x3C/script>')</script>
  
    <script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(t,e){window.heap.appid=t,window.heap.config=e;var a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=("https:"===document.location.protocol?"https:":"http:")+"//cdn.heapanalytics.com/js/heap.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(t){return function(){heap.push([t].concat(Array.prototype.slice.call(arguments,0)))}},p=["clearEventProperties","identify","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
  heap.load("2141231414");
</script>
  <!-- Start Visual Website Optimizer Asynchronous Code -->
<script type='text/javascript'>
var _vwo_code=(function(){
var account_id=22676,
settings_tolerance=2000,
library_tolerance=2500,
use_existing_jquery=false,
// DO NOT EDIT BELOW THIS LINE
f=false,d=document;return{use_existing_jquery:function(){return use_existing_jquery;},library_tolerance:function(){return library_tolerance;},finish:function(){if(!f){f=true;var a=d.getElementById('_vis_opt_path_hides');if(a)a.parentNode.removeChild(a);}},finished:function(){return f;},load:function(a){var b=d.createElement('script');b.src=a;b.type='text/javascript';b.innerText;b.onerror=function(){_vwo_code.finish();};d.getElementsByTagName('head')[0].appendChild(b);},init:function(){settings_timer=setTimeout('_vwo_code.finish()',settings_tolerance);this.load('//dev.visualwebsiteoptimizer.com/j.php?a='+account_id+'&u='+encodeURIComponent(d.URL)+'&r='+Math.random());var a=d.createElement('style'),b='body{opacity:0 !important;filter:alpha(opacity=0) !important;background:none !important;}',h=d.getElementsByTagName('head')[0];a.setAttribute('id','_vis_opt_path_hides');a.setAttribute('type','text/css');if(a.styleSheet)a.styleSheet.cssText=b;else a.appendChild(d.createTextNode(b));h.appendChild(a);return settings_timer;}};}());_vwo_settings_timer=_vwo_code.init();
</script>
<!-- End Visual Website Optimizer Asynchronous Code -->
  

  <!--[if lt IE 7 ]>
    <script src="js/libs/dd_belatedpng.js"></script>
    <script>DD_belatedPNG.fix('img, .png_bg'); // Fix any <img> or .png_bg bg-images. Also, please read goo.gl/mZiyb </script>
  <![endif]-->

    <!-- asynchronous google analytics: mathiasbynens.be/notes/async-analytics-snippet
       change the UA-XXXXX-X to be your site's ID -->
<script>
    var _gaq = [['_setAccount', ''], ['_trackPageview']];
    (function(d, t) {
    var g = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    g.async = true;
    g.src = ('https:' == location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g, s);
    })(document, 'script');
</script>
  
  </body>
</html>