<!doctype html>
<!-- https://github.com/paulirish/html5-boilerplate/blob/master/index.html -->
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
    <meta charset="">

  <!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
       Remove this if you use the .htaccess -->
  <meta http-equiv="X-UA-Compatible" content="">

  <!-- encoding must be specified within the first 512 bytes
        www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#charset -->

  <!-- meta element for compatibility mode needs to be before
        all elements except title & meta
        msdn.microsoft.com/en-us/library/cc288325(VS.85).aspx -->
  <!-- Chrome Frame is only invoked if meta element for
        compatibility mode is within the first 1K bytes
        code.google.com/p/chromium/issues/detail?id=23003 -->

  <title>Understanding Non Blocking I/O with Python - Part 1</title>
  <meta name="description" content="This article is the first in the series of understanding how Non Blocking I/O works in Python. This article takes example of a simple TCP server and client as an example and improves the client script to be non-blocking using select module. At last, we see example of how to implement an event loop for handling network events using select and generators in Python.">
  <meta name="author" content="Vaidik Kapoor">

  <meta prefix="og: http://ogp.me/ns#" property="og:title" content="Understanding Non Blocking I/O with Python - Part 1" />
  <meta prefix="og: http://ogp.me/ns#" property="og:description" content="This article is the first in the series of understanding how Non Blocking I/O works in Python. This article takes example of a simple TCP server and client as an example and improves the client script to be non-blocking using select module. At last, we see example of how to implement an event loop for handling network events using select and generators in Python." />

  <!--  Mobile viewport optimized: j.mp/bplateviewport -->
  <meta name="viewport" content="">

    <!-- Place favicon.ico & apple-touch-icon.png
        in the root of your domain and delete these references -->
  <link rel="shortcut icon" href="/media/favicon.ico">
  <link rel="apple-touch-icon" href="/media/apple-touch-icon.png">
  
  <!-- External Fonts -->
  <link href='http://fonts.googleapis.com/css?family=Mate+SC|Oxygen' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Balthazar' rel='stylesheet' type='text/css'>

  <!-- highlight.js -->
  <link rel="stylesheet" href="http://yandex.st/highlightjs/7.3/styles/default.min.css">
  <script src="http://yandex.st/highlightjs/7.3/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <link rel="canonical" href="https://medium.com/@vaidikkapoor/understanding-non-blocking-i-o-with-python-part-1-ec31a2e2db9b">

  <meta name="google-site-verification" content="wrefK9XS6G7lnOCwGqm6qwdWgfJVbNQIIvY91GqIk4k" />

    <link rel="stylesheet" href="/media/css/site.css">
  <link rel="stylesheet" href="/media/css/syntax.css">
  
    <!-- All JavaScript at the bottom, except for Modernizr which
        enables HTML5 elements & feature detects -->
    <script src="/media/js/libs/modernizr-1.7.min.js"></script>
    </head>
<body id="understanding-non-blocking-io-with-python-part-1">
    <div id="container">
            <div id="main" role="main">
          <header class="clearfix">
              <h1>Vaidik Kapoor</h1>
                                          <nav >
        <a title="Home Page"
        class="home"
        href="/index.html">
        Home
    </a>    <a title="Blog Archives"
        class="active blog"
        href="/blog">
        Archives
    </a>    <a title="About"
        class="about"
        href="/about.html">
        About
    </a></nav>
              
          </header>

          <section class="content">
              <div class="post">
        <article>
            <aside>
                <time datetime="2015-05-31">
                    May 31, 2015
                </time>
            </aside>
            <section>
                <h2>
                    <a href="">Understanding Non Blocking I/O with Python - Part 1</a>
                </h2>
                <p>As someone working with the web stack and languages like Python or Ruby, there
are high chances that you have heard of Non Blocking I/O. You might as well be
using it with some of your projects or have tried your hands with libraries
like Gevent or Tornado. But how do these libraries make network requests non
blocking. This is something that I had always wondered when I tried Gevent. I
just couldn&#8217;t get my head around the fact that when you send something to a
socket or receive from it, it will block execution for the at least the amount
of time it takes to transmit the data. So how do I make it possible to execute
something else while I/O is happening? So I started digging in, trying to
understand how to make some network request non blocking in&nbsp;Python.</p>
<p>With this article series, I will try to introduce the topic and go in as much
detail as&nbsp;possible.</p>
<h3>What is Non Blocking&nbsp;I/O?</h3>
<p>So first lets see what is <strong>Blocking</strong>? A function is blocking if it has to wait
for something to complete. Yes, every function is blocking - no matter if you
are doing I/O or doing <span class="caps">CPU</span> task. Everything takes some time. If a function is
doing some task which is making the <span class="caps">CPU</span> work, then it is blocking the function
from returning. Similarly, if a function is trying to get something from the
database, then it is going to wait for the result to come and will block until
then to continue the processing. But it so happens that the server is not making
any use of the <span class="caps">CPU</span> while it is waiting for the database to send the&nbsp;response.</p>
<p>So if a function is blocking (for whatever reasons), it is capable of delaying
execution of other tasks. And the overall progress of the entire system may get
suffered. If the function is blocking because it is doing some <span class="caps">CPU</span> task, well
then we cannot do much. But if it is blocking because of I/O, we know that the
<span class="caps">CPU</span> is idle and can be used for starting another task that needs <span class="caps">CPU</span>.</p>
<p>Lets see an example of blocking network request. I have a very simple <span class="caps">TCP</span> server
written in&nbsp;Python:</p>
<pre><code>import socket
import sys

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

port = 1234 if len(sys.argv) == 1 else int(sys.argv[1])
sock.bind(('localhost', port))
sock.listen(5)

try:
    while True:
        conn, info = sock.accept()

        data = conn.recv(1024)
        while data:
            print data
            data = conn.recv(1024)
except KeyboardInterrupt:
    sock.close
</code></pre>
<p>And here is a simple client to connect to our&nbsp;server:</p>
<pre><code>import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('localhost', 1234))

data = 'foobar\n' * 10 * 1024 * 1024  # 70 MB of data
assert sock.send(data) == len(data)  # True
</code></pre>
<p>The above code will block for a long period of time. If there was code after the
last time, it will not get executed until <code>send</code> method returns. What is going
on here? The <code>send()</code> method will try to transmit all the data while the write
buffer will get filled up. The kernel will put the process to sleep until the
data in the buffer is transferred to destination and the buffer is empty again.
When the buffer becomes empty, the kernel will wake the process up again to
get the next chunk of data that is to be transferred. In short, your code will
block and it will not let anything else&nbsp;proceed.</p>
<p>Lets make the above example <span class="caps">NOT</span>&nbsp;block:</p>
<pre><code>import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('localhost', 1234))
sock.setblocking(0)

data = 'foobar\n' * 10 * 1024 * 1024  # 70 MB of data
assert sock.send(data) == len(data)  # AssertionError
</code></pre>
<p>When you run the above client, you will notice that it did not block at all. But
there is a problem with the client - it did not send all the data.
<code>socket.send</code> method returns the number of bytes sent. When you make a
socket non-blocking by calling <code>setblocking(0)</code>, it will never wait for the
operation to complete. So when you call the <code>send()</code> method, it will put as much
data in the buffer as possible and return. As this is read by the remote
connection, the data is removed from the buffer. If the buffer gets <strong><em>full</em></strong>
and we continue to send data, <code>socket.error</code> will be raised. When you try to
send data more than the buffer can accommodate, only the amount of data that
can be accommodated is actually sent and <code>send()</code> returns the number of bytes
sent. This is useful so that we can try to send the remaining data when the
buffer becomes empty. Let&#8217;s try to achieve&nbsp;that:</p>
<pre><code>import errno
import select
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('localhost', 1234))
sock.setblocking(0)

data = 'foobar\n' * 1024 * 1024
data_size = len(data)
print 'Bytes to send: ', len(data)

total_sent = 0
while len(data):
    try:
        sent = sock.send(data)
        total_sent += sent
        data = data[sent:]
        print 'Sending data'
    except socket.error, e:
        if e.errno != errno.EAGAIN:
            raise e
        print 'Blocking with', len(data), 'remaining'
        select.select([], [sock], [])  # This blocks until

assert total_sent == data_size  # True
</code></pre>
<p>In the above example, we make sure that we keep trying to send the remaining
data as long as we have not sent all of it. When the write buffer is full and
cannot accommodate more data, <code>EAGAIN</code> error is raised asking us to try again.
If you examine the exception object, the exception message is &#8220;Resource
temporarily unavailable&#8221;. So we keep trying to send the remaining data until we
have sent it&nbsp;all.</p>
<h3>Understanding&nbsp;select()</h3>
<p>The last line of the above example introduces the <a href="https://docs.python.org/2/library/select.html">select</a> module. select module
helps us with dealing with multiple file descriptors at once. The select module
includes implementations of <code>select</code>, <code>poll</code>, <code>epoll</code> and <code>kqueue</code>, which are
used by libraries like eventlet, twisted, tornado and others. We will look at
them later in the coming articles of this series. Since we made our socket
non-blocking, we don&#8217;t know when can we actually write to it unless we keep
trying to write to it and expect it to not fail. This is a major waste of <span class="caps">CPU</span>
time. In the above example, we call the <code>select()</code> function to avoid exactly&nbsp;that.</p>
<p><code>select()</code> expects three arguments - list of file descriptors to watch for
reading, list of file descriptors to watch for writing and list of file
descriptors to watch for errors. Timeout can be passed as an optional 4th
argument which can be used to prevent <code>select()</code> from blocking indefinitely.
It returns a subset of all the three lists passed in the same order i.e. all
the file descriptors that are ready for reading, writing or have caused some&nbsp;error.</p>
<p>We call the <code>select()</code> function and pass it file descriptors asking it to tell
us which of these are ready for reading or writing. In the above example,
<code>select()</code> blocks if there is no file descriptor that is ready to work with.
You might say that this is still blocking the execution of our program but this
is just the foundation for building better things. As of now, <code>select()</code> will
just block until our sock object becomes writeable again. If we remove that
line, our script will continue to work but a lot more useless while loop
iterations will be run as most of them will result in&nbsp;exceptions.</p>
<p>But how does <code>select()</code> really work? Well, <code>select()</code> is nothing but an
interface to the Unix <code>select()</code> system call. And its pretty easy to understand
as the usage does not differ so much from the Python interface. For the curious
ones, you can read more about in the <a href="http://linux.die.net/man/2/select">man page for select</a> and at
these&nbsp;links:</p>
<ul>
<li>http://en.wikipedia.org/wiki/Select_(Unix)</li>
<li>http://www.quora.com/Network-Programming/How-is-select-implemented</li>
</ul>
<h3>Introduction to event loops for network&nbsp;events</h3>
<p>Now that we understand <code>select</code> better, lets make use of it to do better than
our last example where we actually make use of making a socket non-blocking. We
are going to make use of generators to make sure that our script does not block
execution of other things and let other code proceed as well. Consider this&nbsp;example:</p>
<pre><code>import errno
import select
import socket
import time


def other_task():
    i = 0
    while i &lt; 2000:
        i += 1
        print i
        time.sleep(0.02)
        yield


def send_data_task(port, data):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(('localhost', port))
    sock.setblocking(0)

    data = (data + '\n') * 1024 * 1024
    print 'Bytes to send: ', len(data)

    total_sent = 0
    while len(data):
        try:
            sent = sock.send(data)
            total_sent += sent
            data = data[sent:]
            print 'Sending data'
        except socket.error, e:
            if e.errno != errno.EAGAIN:
                raise e
            yield ('w', sock)

    print 'Bytes sent: ', total_sent


if __name__ == '__main__':
    tasks = [
        other_task(),
        send_data_task(port=1234, data='foo'),
        send_data_task(port=5678, data='bar'),
    ]

    fds = dict(w={}, r={})
    while len(tasks) or len(fds['w']) or len(fds['r']):
        new_tasks = []
        for task in tasks:
            try:
                resp = next(task)
                try:
                    iter(resp)
                    fds[resp[0]][resp[1]] = task
                except TypeError:
                    # this task has to be done since not dependent on any fd
                    new_tasks.append(task)
            except StopIteration:
                # function completed
                pass

        if len(fds['w'].keys()) or len(fds['r'].keys()):
            readable, writeable, exceptional = select.select(
                fds['r'].keys(), fds['w'].keys(), [], 0)
            for readable_sock in readable:
                new_tasks.append(fds['r'][fd])
                del fds['r'][fd]
            for fd in writeable:
                new_tasks.append(fds['w'][fd])
                del fds['w'][fd]
            # ignore exceptional for now

        tasks = new_tasks
</code></pre>
<p>For running this example, we are going to run two instances of servers and make
our script do two things simultaneously - run a function that just increments
a variable in a loop and send data to two servers. Both the servers are
essentially the same. They are just running on different ports so that our
script can connect to two servers at the same&nbsp;time.</p>
<p>In the above example, we have two functions <code>send_data_task()</code> and
<code>other_task()</code>. <code>send_data_task()</code> tries to send a lot of data to a <span class="caps">TCP</span> server.
<code>other_task()</code> just runs a counter. We want to execute both the functions. If
we execute them one by one, then we end up blocking the one executing later.
However, we can have both the functions proceed simultaneously. We make use of
non-blocking sockets and generators to make two functions proceed&nbsp;co-operatively.</p>
<p>The <code>send_data_task()</code> function creates a non-blocking socket and tries to send
data just like our previous example. The only difference is that it <code>yields</code>
when the write buffer gets full and an exception is raised. Since we cannot
send any more data through the socket any more, we can have another block of
code proceed that does not depend on this function. <code>other_task()</code> function is
a simple function for this example that just runs a counter in a loop. This
function also yields after every iteration of the&nbsp;loop.</p>
<p>In case of <code>send_data_task()</code>, we <code>yield</code> when we cannot send more data since
our write buffer is full. But when we yield, we also return a tuple with the
type of operations on the socket (&#8216;w&#8217; for write, &#8216;r&#8217; for read) and the socket
object itself. When the execution is returned to the callee, we maintain a
mapping of socket objects to the generator that returned&nbsp;it.</p>
<p>In case of <code>other_task</code>, we yield after every iteration. Why? If we don&#8217;t do
that, the function will continue to execute until it has completed all that it
has to do and our other function <code>send_data_task()</code> will not get a chance to
proceed. So we consciously try to switch execution to another function whenever
possible. Since this function does not depend on any fd or socket object, we
don&#8217;t return anything when we yield. This is just a way we have designed our
implementation - ugly as it may look but it keeps things simple to&nbsp;understand.</p>
<p>In our main block, we maintain a list of functions that we want to call in a
list called <code>tasks</code>. To be precise, both our functions use <code>yield</code> and hence
return generators when we call them. So <code>tasks</code> actually maintains a list of
generators returned by the functions we want to co-operatively execute. We run
a loop as long as our tasks don&#8217;t complete their execution. On every iteration
of the loop, we run each task one-by-one using the <code>next()</code> function. The
function resumes its execution and yields whenever it&nbsp;can.</p>
<p>The while loop runs as long as tasks list is not empty or we have any fds or
socket objects to watch. We run every task one-by-one. When we call
<code>send_data_task</code>, it yields a tuple with the operation (reading or writing) we
were performing on the socket and the socket object itself. We keep the socket
object in a dictionary called <code>fds</code> where we maintain two different
dictionaries of objects - one for those which we are writing to and another for
those we are reading from. Then we run the <code>other_task()</code> and it yields&nbsp;nothing.</p>
<p>The execution gets returned to the main block. After executing the tasks, we
see if there are any socket objects or fds that we need to watch using
<code>select()</code> and call it accordingly. <code>select()</code> returns a subset of sockets/fds
that can be read from or written to. If we can read from a or write to any
socket/fd, we look for the corresponding generator in the corresponding
dictionary in <code>fds</code> and append it to a new list of tasks that shall be executed
in the next iteration of our main while loop. Finally, we just replace tasks
with <code>new_tasks</code> so that the while loops picks up the new&nbsp;tasks.</p>
<p>This keeps on running until we have no tasks left in the tasks list and no more
sockets/fds to watch. And this way, our functions co-operatively let each other
proceed. The example is perhaps ugly and not even close to real-world usage but
its simple and it gets the idea&nbsp;across.</p>
<p>That large while loop that you see in our main block is our implementation of
event loop for our script. What does it do? It just watches for network events
and schedules corresponding code blocks to run as and when they can. However,
our implementation is a very simple implementation and it surely does not handle
the most common things. It is just enough for undersanding the&nbsp;concept.</p>
<h3>Examples</h3>
<p>All the code examples in this article can be found <a href="https://github.com/vaidik/nonblocking-io-examples">here</a>.</p>
<h3>What&#8217;s&nbsp;next?</h3>
<p>That was an introduction on how you can make sockets non-blocking and use select
function from the select module to watch file descriptors for reading or
writing. We understood how select() works, made a script that does network I/O
not block using non-blocking sockets and made use of generators and select() to
implement a very simple I/O&nbsp;loop.</p>
<p>In the next article, we will look at more examples and look at other
infrastructure for handling non-blocking sockets such as poll and&nbsp;epoll.</p>            </section>
        </article>

        <section>
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                var disqus_shortname = 'vaidikkapoor'; // required: replace example with your forum shortname

                /* * * DON'T EDIT BELOW THIS LINE * * */
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </section>
    </div>          </section>
      </div>

      <footer>
                              <nav >
        <a title="Home Page"
        class="home"
        href="/index.html">
        Home
    </a>    <a title="Blog Archives"
        class="active blog"
        href="/blog">
        Archives
    </a>    <a title="About"
        class="about"
        href="/about.html">
        About
    </a></nav>
                    <section class="credits">
              Built using <a href="http://ringce.com/hyde" target="_blank">Hyde</a>.
          </section>
      </footer>
      </div> <!--! end of #container -->
  
    <!-- Javascript at the bottom for fast page loading -->
    <!-- Grab Google CDN's jQuery, with a protocol relative URL; fall back to local if necessary -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.js"></script>
  <script>window.jQuery || document.write('<script src="js/libs/jquery-1.5.1.min.js">\x3C/script>')</script>
  
    <script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(t,e){window.heap.appid=t,window.heap.config=e;var a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=("https:"===document.location.protocol?"https:":"http:")+"//cdn.heapanalytics.com/js/heap.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(t){return function(){heap.push([t].concat(Array.prototype.slice.call(arguments,0)))}},p=["clearEventProperties","identify","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
  heap.load("2141231414");
</script>
  <!-- Start Visual Website Optimizer Asynchronous Code -->
<script type='text/javascript'>
var _vwo_code=(function(){
var account_id=22676,
settings_tolerance=2000,
library_tolerance=2500,
use_existing_jquery=false,
// DO NOT EDIT BELOW THIS LINE
f=false,d=document;return{use_existing_jquery:function(){return use_existing_jquery;},library_tolerance:function(){return library_tolerance;},finish:function(){if(!f){f=true;var a=d.getElementById('_vis_opt_path_hides');if(a)a.parentNode.removeChild(a);}},finished:function(){return f;},load:function(a){var b=d.createElement('script');b.src=a;b.type='text/javascript';b.innerText;b.onerror=function(){_vwo_code.finish();};d.getElementsByTagName('head')[0].appendChild(b);},init:function(){settings_timer=setTimeout('_vwo_code.finish()',settings_tolerance);this.load('//dev.visualwebsiteoptimizer.com/j.php?a='+account_id+'&u='+encodeURIComponent(d.URL)+'&r='+Math.random());var a=d.createElement('style'),b='body{opacity:0 !important;filter:alpha(opacity=0) !important;background:none !important;}',h=d.getElementsByTagName('head')[0];a.setAttribute('id','_vis_opt_path_hides');a.setAttribute('type','text/css');if(a.styleSheet)a.styleSheet.cssText=b;else a.appendChild(d.createTextNode(b));h.appendChild(a);return settings_timer;}};}());_vwo_settings_timer=_vwo_code.init();
</script>
<!-- End Visual Website Optimizer Asynchronous Code -->
  

  <!--[if lt IE 7 ]>
    <script src="js/libs/dd_belatedpng.js"></script>
    <script>DD_belatedPNG.fix('img, .png_bg'); // Fix any <img> or .png_bg bg-images. Also, please read goo.gl/mZiyb </script>
  <![endif]-->

    <!-- asynchronous google analytics: mathiasbynens.be/notes/async-analytics-snippet
       change the UA-XXXXX-X to be your site's ID -->
<script>
    var _gaq = [['_setAccount', ''], ['_trackPageview']];
    (function(d, t) {
    var g = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    g.async = true;
    g.src = ('https:' == location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g, s);
    })(document, 'script');
</script>
  
  </body>
</html>